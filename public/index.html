<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Codebase Visualizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; color: #e0e0e0; font-family: 'Inter', -apple-system, sans-serif; overflow: hidden; user-select: none; }

    /* Project info — top left */
    #project-bar {
      position: fixed; top: 12px; left: 16px; z-index: 100;
      padding: 10px 14px; background: rgba(10,10,15,0.85); border: 1px solid #222;
      border-radius: 10px; backdrop-filter: blur(12px);
    }
    #project-bar h1 { font-size: 14px; font-weight: 600; color: #fff; white-space: nowrap; margin-bottom: 8px; }
    .stats-row {
      display: flex; justify-content: space-between; gap: 16px;
      padding: 2px 0; color: #888; font-size: 11px;
    }
    .stats-row span { color: #e0e0e0; font-weight: 500; }
    .stats-divider { height: 1px; background: #333; margin: 6px 0; }

    /* View switcher — center top */
    #view-bar {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%); z-index: 100;
      display: flex; align-items: center; gap: 4px;
    }
    .view-tab {
      padding: 4px 10px; font-size: 11px; border-radius: 4px;
      background: rgba(10,10,15,0.85); color: #888; border: 1px solid #333;
      cursor: pointer; transition: all 0.2s; backdrop-filter: blur(12px);
    }
    .view-tab:hover { background: #252530; color: #ccc; }
    .view-tab.active { background: #2563eb; color: #fff; border-color: #2563eb; }

    /* Search — top right floating */
    #search {
      position: fixed; top: 12px; right: 16px; z-index: 100;
      padding: 6px 12px; font-size: 12px;
      background: rgba(10,10,15,0.85); color: #e0e0e0; border: 1px solid #222;
      border-radius: 10px; outline: none; width: 180px;
      backdrop-filter: blur(12px);
    }
    #search:focus { border-color: #2563eb; }

    /* Graph container */
    #graph { width: 100vw; height: 100vh; }

    /* Detail panel */
    #detail {
      position: fixed; top: 84px; right: 12px; width: 320px; max-height: calc(100vh - 96px);
      border-radius: 10px;
      background: rgba(15,15,25,0.95); border-left: 1px solid #222;
      padding: 16px; overflow-y: auto; display: none; z-index: 50;
    }
    #detail.visible { display: block; }
    #detail h2 { font-size: 14px; color: #fff; margin-bottom: 8px; word-break: break-all; }
    #detail .metric { display: flex; justify-content: space-between; padding: 4px 0; font-size: 12px; border-bottom: 1px solid #1a1a24; }
    #detail .metric-label { color: #888; }
    #detail .metric-value { color: #e0e0e0; font-weight: 500; }
    #detail .section-title { font-size: 11px; color: #2563eb; text-transform: uppercase; margin-top: 12px; margin-bottom: 4px; }
    #detail .dep-list { font-size: 11px; color: #aaa; }
    #detail .dep-list div { padding: 2px 0; cursor: pointer; }
    #detail .dep-list div:hover { color: #2563eb; }
    #detail .close-btn {
      position: absolute; top: 8px; right: 8px; background: none; border: none;
      color: #666; cursor: pointer; font-size: 16px;
    }

    /* Legend */
    #legend {
      position: fixed; bottom: 16px; left: 16px; z-index: 50;
      background: rgba(15,15,25,0.85); border: 1px solid #222; border-radius: 10px;
      padding: 10px 14px; font-size: 11px; backdrop-filter: blur(12px);
    }
    #legend .item { display: flex; align-items: center; gap: 6px; padding: 2px 0; }
    #legend .dot { width: 8px; height: 8px; border-radius: 50%; }

    /* Force analysis legend */
    .force-legend { display: none; }
    .force-legend.visible { display: block; }

    /* Config panel — always visible, bottom right */
    #config-panel {
      position: fixed; bottom: 16px; right: 16px; z-index: 100;
      width: 240px; background: rgba(15,15,25,0.85);
      border: 1px solid #222; border-radius: 10px;
      padding: 16px; backdrop-filter: blur(12px);
    }
    .config-title {
      font-size: 12px; font-weight: 600; color: #fff;
      margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .config-section {
      font-size: 10px; color: #2563eb; text-transform: uppercase;
      margin: 12px 0 6px; letter-spacing: 0.5px;
    }
    .config-section:first-of-type { margin-top: 0; }
    .config-group { margin-bottom: 8px; }
    .config-group label {
      display: flex; justify-content: space-between;
      font-size: 11px; color: #888; margin-bottom: 3px;
    }
    .config-group label span { color: #e0e0e0; font-weight: 500; min-width: 32px; text-align: right; }
    .config-group input[type="range"] {
      width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
      background: #333; border-radius: 2px; outline: none;
    }
    .config-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px;
      border-radius: 50%; background: #2563eb; cursor: pointer;
    }
    .config-group input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border: none;
      border-radius: 50%; background: #2563eb; cursor: pointer;
    }
    .config-group input[type="color"] {
      width: 32px; height: 20px; border: 1px solid #333; border-radius: 3px;
      background: none; cursor: pointer; padding: 0;
    }
    .config-color-row {
      display: flex; align-items: center; justify-content: space-between;
      font-size: 11px; color: #888; margin-bottom: 8px;
    }
    .config-color-row span { color: #e0e0e0; }
    .config-check {
      display: flex; align-items: center; gap: 6px;
      font-size: 11px; color: #888; margin-bottom: 8px; cursor: pointer;
    }
    .config-check input { accent-color: #2563eb; cursor: pointer; }
    .config-check span { color: #e0e0e0; }
  </style>
</head>
<body>
  <div id="project-bar">
    <h1 id="project-title">Codebase Visualizer</h1>
    <div class="stats-row">Files <span id="stat-files">—</span></div>
    <div class="stats-row">Functions <span id="stat-functions">—</span></div>
    <div class="stats-row">Dependencies <span id="stat-deps">—</span></div>
    <div class="stats-row">Circular <span id="stat-circular">—</span></div>
    <div class="stats-divider"></div>
    <div class="stats-row">Test Coverage <span id="stat-coverage">—</span></div>
    <div class="stats-row">Dead Exports <span id="stat-dead">—</span></div>
    <div class="stats-row">Avg Complexity <span id="stat-complexity">—</span></div>
    <div class="stats-row">Tension Files <span id="stat-tension">—</span></div>
    <div class="stats-row">Bridges <span id="stat-bridges">—</span></div>
  </div>
  <div id="view-bar">
    <div class="view-tab active" data-view="galaxy">Galaxy</div>
    <div class="view-tab" data-view="depflow">Dep Flow</div>
    <div class="view-tab" data-view="hotspot">Hotspot</div>
    <div class="view-tab" data-view="focus">Focus</div>
    <div class="view-tab" data-view="module">Module</div>
    <div class="view-tab" data-view="forces">Forces</div>
    <div class="view-tab" data-view="churn">Churn</div>
    <div class="view-tab" data-view="coverage">Coverage</div>
  </div>
  <input id="search" type="text" placeholder="Search files..." />
  <div id="graph"></div>
  <div id="detail">
    <button class="close-btn" id="close-detail-btn">&times;</button>
    <div id="detail-content"></div>
  </div>
  <div id="legend"></div>

  <div id="config-panel">
    <div class="config-title">Settings</div>
    <div class="config-section">Nodes</div>
    <div class="config-group">
      <label>Opacity <span id="val-nodeOpacity">0.9</span></label>
      <input type="range" id="cfg-nodeOpacity" min="0.1" max="1" step="0.05" value="0.9">
    </div>
    <div class="config-group">
      <label>Size <span id="val-nodeSize">1.0</span></label>
      <input type="range" id="cfg-nodeSize" min="0.2" max="3" step="0.1" value="1">
    </div>
    <div class="config-group">
      <label>Dim Isolated <span id="val-isolatedDim">0.3</span></label>
      <input type="range" id="cfg-isolatedDim" min="0" max="1" step="0.05" value="0.3">
    </div>
    <div class="config-section">Links</div>
    <div class="config-color-row">
      <span>Color</span>
      <input type="color" id="cfg-linkColor" value="#969696">
    </div>
    <div class="config-group">
      <label>Opacity <span id="val-linkOpacity">0.8</span></label>
      <input type="range" id="cfg-linkOpacity" min="0.05" max="1" step="0.05" value="0.8">
    </div>
    <div class="config-group">
      <label>Width <span id="val-linkWidth">0.3</span></label>
      <input type="range" id="cfg-linkWidth" min="0.1" max="3" step="0.1" value="0.3">
    </div>
    <div class="config-section">Grouping</div>
    <label class="config-check"><input type="checkbox" id="cfg-moduleBoxes" checked> <span>Module Clouds</span></label>
    <div class="config-group">
      <label>Cloud Opacity <span id="val-boxOpacity">0.40</span></label>
      <input type="range" id="cfg-boxOpacity" min="0.05" max="0.8" step="0.05" value="0.4">
    </div>
    <div class="config-section">Physics</div>
    <div class="config-group">
      <label>Repulsion <span id="val-charge">-30</span></label>
      <input type="range" id="cfg-charge" min="-200" max="-5" step="5" value="-30">
    </div>
    <div class="config-group">
      <label>Distance <span id="val-distance">120</span></label>
      <input type="range" id="cfg-distance" min="30" max="500" step="10" value="120">
    </div>
  </div>

  <script src="https://unpkg.com/three@0.170.0/build/three.min.js"></script>
  <script src="https://unpkg.com/3d-force-graph@1"></script>
  <script>
    let graphData = null;
    let forceData = null;
    let graph3d = null;
    let currentView = 'galaxy';
    let focusNode = null;
    let nodeById = new Map();

    // Safe DOM helpers — prevent XSS
    function el(tag, attrs, ...children) {
      const node = document.createElement(tag);
      if (attrs) {
        for (const [k, v] of Object.entries(attrs)) {
          if (k === 'style' && typeof v === 'object') {
            Object.assign(node.style, v);
          } else if (k.startsWith('on') && typeof v === 'function') {
            node.addEventListener(k.slice(2), v);
          } else if (k === 'className') {
            node.className = v;
          } else {
            node.setAttribute(k, v);
          }
        }
      }
      for (const child of children) {
        if (typeof child === 'string') node.appendChild(document.createTextNode(child));
        else if (child instanceof Node) node.appendChild(child);
      }
      return node;
    }

    function text(str) { return document.createTextNode(String(str)); }

    // Color palette for modules
    const MODULE_COLORS = [
      '#2563eb', '#dc2626', '#16a34a', '#9333ea', '#ea580c',
      '#0891b2', '#ca8a04', '#e11d48', '#4f46e5', '#059669'
    ];
    const moduleColorMap = new Map();
    let colorIdx = 0;

    function getModuleColor(mod) {
      if (!moduleColorMap.has(mod)) {
        moduleColorMap.set(mod, MODULE_COLORS[colorIdx % MODULE_COLORS.length]);
        colorIdx++;
      }
      return moduleColorMap.get(mod);
    }

    // Config state
    const cfg = {
      nodeOpacity: 0.9,
      nodeSize: 1.0,
      isolatedDim: 0.3,
      linkColor: '#969696',
      linkOpacity: 0.8,
      linkWidth: 0.3,
      charge: -30,
      distance: 120,
      showModuleBoxes: true,
      boxOpacity: 0.4,
    };

    // Module clouds (3D sphere meshes + text labels)
    const moduleClouds = new Map();

    function makeLabelSprite(text, hexColor) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512; canvas.height = 64;
      ctx.font = 'bold 36px Inter, -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 6;
      ctx.strokeText(text, 256, 32);
      ctx.fillStyle = '#fff';
      ctx.fillText(text, 256, 32);
      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(100, 12, 1);
      return sprite;
    }

    function clearModuleClouds() {
      if (!graph3d) return;
      const scene = graph3d.scene();
      moduleClouds.forEach(obj => {
        obj.mesh.geometry.dispose();
        obj.mesh.material.dispose();
        scene.remove(obj.mesh);
        obj.label.material.map.dispose();
        obj.label.material.dispose();
        scene.remove(obj.label);
      });
      moduleClouds.clear();
    }

    function updateModuleBoxes() {
      if (!graph3d || typeof THREE === 'undefined') return;
      if (!cfg.showModuleBoxes) { clearModuleClouds(); return; }

      const scene = graph3d.scene();
      const nodes = graph3d.graphData().nodes;

      const groups = new Map();
      nodes.forEach(n => {
        if (n.x === undefined) return;
        // Skip worktree duplicates
        if (n.module.startsWith('.worktrees/')) return;
        if (!groups.has(n.module)) groups.set(n.module, []);
        groups.get(n.module).push(n);
      });

      const active = new Set();
      groups.forEach((moduleNodes, mod) => {
        if (moduleNodes.length < 3) return;
        active.add(mod);

        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        moduleNodes.forEach(n => {
          minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
          minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
          minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
        });

        const pad = 20;
        const rx = Math.max((maxX - minX) / 2 + pad, 12);
        const ry = Math.max((maxY - minY) / 2 + pad, 12);
        const rz = Math.max((maxZ - minZ) / 2 + pad, 12);
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        const cz = (minZ + maxZ) / 2;

        const existing = moduleClouds.get(mod);
        if (existing) {
          existing.mesh.position.set(cx, cy, cz);
          existing.mesh.scale.set(rx, ry, rz);
          existing.mesh.material.opacity = cfg.boxOpacity * 0.25;
          existing.label.position.set(cx, maxY + pad + 8, cz);
        } else {
          const color = getModuleColor(mod);

          // Semi-transparent sphere
          const geo = new THREE.SphereGeometry(2, 24, 16);
          const mat = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: cfg.boxOpacity * 0.25,
            depthWrite: false,
            side: THREE.BackSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(cx, cy, cz);
          mesh.scale.set(rx, ry, rz);
          scene.add(mesh);

          // Floating label
          const label = makeLabelSprite(mod, color);
          label.position.set(cx, maxY + pad + 8, cz);
          scene.add(label);

          moduleClouds.set(mod, { mesh, label });
        }
      });

      moduleClouds.forEach((obj, mod) => {
        if (!active.has(mod)) {
          obj.mesh.geometry.dispose();
          obj.mesh.material.dispose();
          scene.remove(obj.mesh);
          obj.label.material.map.dispose();
          obj.label.material.dispose();
          scene.remove(obj.label);
          moduleClouds.delete(mod);
        }
      });
    }

    function linkRgba(alpha) {
      const h = cfg.linkColor;
      const r = parseInt(h.slice(1,3), 16);
      const g = parseInt(h.slice(3,5), 16);
      const b = parseInt(h.slice(5,7), 16);
      return `rgba(${r},${g},${b},${alpha ?? cfg.linkOpacity})`;
    }

    function isIsolated(n) { return n.fanIn === 0 && n.fanOut === 0; }

    function dimColor(hex, factor) {
      let r, g, b;
      if (hex.startsWith('#')) {
        r = parseInt(hex.slice(1,3), 16);
        g = parseInt(hex.slice(3,5), 16);
        b = parseInt(hex.slice(5,7), 16);
      } else if (hex.startsWith('rgb')) {
        const m = hex.match(/(\d+)/g);
        if (!m) return hex;
        r = +m[0]; g = +m[1]; b = +m[2];
      } else { return hex; }
      return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
    }

    function nodeColor(n, baseColor) {
      return isIsolated(n) ? dimColor(baseColor, cfg.isolatedDim) : baseColor;
    }

    function nodeSize(n, baseSize) {
      return (isIsolated(n) ? baseSize * cfg.isolatedDim : baseSize) * cfg.nodeSize;
    }

    // Health color: green -> orange -> red
    function healthColor(score) {
      const r = Math.min(255, Math.floor(score * 2 * 255));
      const g = Math.min(255, Math.floor((1 - score) * 2 * 255));
      return `rgb(${r},${g},60)`;
    }

    // Human-readable complexity rating
    function complexityLabel(val) {
      if (val <= 5) return { text: 'Simple', color: '#16a34a' };
      if (val <= 10) return { text: 'Moderate', color: '#ca8a04' };
      if (val <= 20) return { text: 'Complex', color: '#ea580c' };
      return { text: 'Very Complex', color: '#dc2626' };
    }

    async function fetchData(retries) {
      for (let i = 0; i <= retries; i++) {
        try {
          const [graphRes, forcesRes, metaRes] = await Promise.all([
            fetch('/api/graph'),
            fetch('/api/forces'),
            fetch('/api/meta')
          ]);
          if (!graphRes.ok || !forcesRes.ok) throw new Error('Server returned error');
          graphData = await graphRes.json();
          forceData = await forcesRes.json();
          if (metaRes.ok) {
            const meta = await metaRes.json();
            document.getElementById('project-title').textContent = meta.projectName;
            document.title = meta.projectName + ' — Codebase Visualizer';
          }
          return true;
        } catch (err) {
          if (i < retries) {
            await new Promise(r => setTimeout(r, 500 * (i + 1)));
          } else {
            document.getElementById('graph').innerHTML = '';
            document.getElementById('graph').appendChild(
              el('div', { style: { color: '#ef4444', padding: '40px', textAlign: 'center', fontSize: '16px' } },
                'Failed to load graph data: ' + (err instanceof Error ? err.message : String(err))
              )
            );
            return false;
          }
        }
      }
      return false;
    }

    function waitForLayout() {
      return new Promise(resolve => {
        requestAnimationFrame(() => requestAnimationFrame(resolve));
      });
    }

    async function init() {
      const ok = await fetchData(3);
      if (!ok) return;

      // Build O(1) lookup map
      nodeById = new Map(graphData.nodes.map(n => [n.id, n]));

      document.getElementById('stat-files').textContent = String(graphData.stats.totalFiles);
      document.getElementById('stat-functions').textContent = String(graphData.stats.totalFunctions);
      document.getElementById('stat-deps').textContent = String(graphData.stats.totalDependencies);
      document.getElementById('stat-circular').textContent = String(graphData.stats.circularDeps.length);

      // Computed analytics stats
      const fileNodes = graphData.nodes.filter(n => n.type === 'file');
      const testedCount = fileNodes.filter(n => n.hasTests).length;
      const totalFiles = fileNodes.length || 1;
      const coveragePct = Math.round((testedCount / totalFiles) * 100);
      const coverageSpan = document.getElementById('stat-coverage');
      coverageSpan.textContent = testedCount + '/' + totalFiles + ' (' + coveragePct + '%)';
      coverageSpan.style.color = coveragePct >= 60 ? '#16a34a' : coveragePct >= 30 ? '#ca8a04' : '#dc2626';

      const totalDead = fileNodes.reduce((sum, n) => sum + (n.deadExports ? n.deadExports.length : 0), 0);
      document.getElementById('stat-dead').textContent = String(totalDead);

      const avgComplexity = fileNodes.reduce((sum, n) => sum + (n.cyclomaticComplexity || 1), 0) / totalFiles;
      const cxLabel = complexityLabel(avgComplexity);
      const cxSpan = document.getElementById('stat-complexity');
      cxSpan.textContent = avgComplexity.toFixed(1) + ' — ' + cxLabel.text;
      cxSpan.style.color = cxLabel.color;

      document.getElementById('stat-tension').textContent = String(forceData.tensionFiles.length);
      document.getElementById('stat-bridges').textContent = String(forceData.bridgeFiles.length);

      // Wait for browser to compute layout (container needs real dimensions for WebGL canvas)
      await waitForLayout();

      renderGalaxy();
      setupEvents();
      setupConfig();

      // Safety net: if container got zero-sized, re-render on resize
      window.addEventListener('resize', () => {
        if (graph3d) {
          const c = document.getElementById('graph');
          graph3d.width(c.clientWidth).height(c.clientHeight);
        }
      });
    }

    function renderGalaxy() {
      currentView = 'galaxy';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: e.isTypeOnly ? linkRgba(0.4) : linkRgba(0.6),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} (${n.loc} LOC)`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .linkOpacity(cfg.linkOpacity)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('galaxy');
    }

    function renderDepFlow() {
      currentView = 'depflow';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const circularPairs = new Set();
      (graphData.stats.circularDeps || []).forEach(cycle => {
        for (let i = 0; i < cycle.length - 1; i++) {
          circularPairs.add(`${cycle[i]}->${cycle[i+1]}`);
        }
      });

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: circularPairs.has(`${e.source}->${e.target}`) || circularPairs.has(`${e.target}->${e.source}`)
            ? 'rgba(220,38,38,0.8)' : linkRgba(0.6),
          width: circularPairs.has(`${e.source}->${e.target}`) ? 2 : cfg.linkWidth,
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .dagMode('td')
        .dagLevelDistance(50)
        .nodeLabel(n => n.path)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('depflow');
    }

    function renderHotspot() {
      currentView = 'hotspot';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = healthColor(n.coupling);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 1 + n.loc / 20) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: linkRgba(0.5),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} (coupling: ${n.coupling.toFixed(2)})`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('hotspot');
    }

    function renderFocus(targetId) {
      currentView = 'focus';
      focusNode = targetId;
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const neighbors = new Set();
      neighbors.add(targetId);
      graphData.edges.forEach(e => {
        if (e.source === targetId) { neighbors.add(e.target); }
        if (e.target === targetId) { neighbors.add(e.source); }
      });
      // 2-hop
      const hop2 = new Set(neighbors);
      graphData.edges.forEach(e => {
        if (neighbors.has(e.source)) hop2.add(e.target);
        if (neighbors.has(e.target)) hop2.add(e.source);
      });

      const data = {
        nodes: graphData.nodes.map(n => {
          const inFocus = hop2.has(n.id);
          return {
            ...n,
            color: n.id === targetId ? '#fbbf24'
              : neighbors.has(n.id) ? getModuleColor(n.module)
              : inFocus ? getModuleColor(n.module)
              : '#1a1a24',
            size: (n.id === targetId ? 8 : neighbors.has(n.id) ? 4 : inFocus ? 2 : 0.5) * cfg.nodeSize,
          };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: (hop2.has(e.source) && hop2.has(e.target)) ? linkRgba(0.7) : linkRgba(0.1),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => n.path)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => {
          if (n.id !== targetId) renderFocus(n.id);
          showDetail(n);
        });

      applyForces();
      updateLegend('focus');
    }

    function renderModule() {
      currentView = 'module';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => {
          const sn = nodeById.get(e.source);
          const tn = nodeById.get(e.target);
          const crossModule = sn && tn && sn.module !== tn.module;
          return {
            source: e.source, target: e.target,
            color: crossModule ? 'rgba(255,200,50,0.5)' : linkRgba(0.4),
            width: crossModule ? 1.5 : cfg.linkWidth,
          };
        })
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.module}${n.label}`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('module');
    }

    function renderForces() {
      currentView = 'forces';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const tensionSet = new Set(forceData.tensionFiles.map(t => t.file));
      const bridgeSet = new Set(forceData.bridgeFiles.map(b => b.file));
      const junkModules = new Set(forceData.moduleCohesion.filter(m => m.verdict === 'JUNK_DRAWER').map(m => m.path));
      const extractModules = new Set(forceData.extractionCandidates.map(e => e.target));

      const data = {
        nodes: graphData.nodes.map(n => {
          let color = getModuleColor(n.module);
          let size = 2 + Math.sqrt(n.pageRank * 10000);

          if (tensionSet.has(n.id)) { color = '#fbbf24'; size *= 1.5; } // Yellow for tension
          else if (bridgeSet.has(n.id)) { color = '#06b6d4'; size *= 1.3; } // Cyan for bridges
          else if (junkModules.has(n.module)) { color = '#ef4444'; } // Red for junk drawer members
          else if (extractModules.has(n.module)) { color = '#22c55e'; } // Green for extraction candidates

          return { ...n, color: nodeColor(n, color), size: nodeSize(n, size) };
        }),
        links: graphData.edges.map(e => {
          const sn = nodeById.get(e.source);
          const tn = nodeById.get(e.target);
          const crossModule = sn && tn && sn.module !== tn.module;
          return {
            source: e.source, target: e.target,
            color: crossModule ? 'rgba(239,68,68,0.4)' : linkRgba(0.4),
            width: crossModule ? 1 : cfg.linkWidth,
          };
        })
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => {
          if (tensionSet.has(n.id)) return `TENSION: ${n.path}`;
          if (bridgeSet.has(n.id)) return `BRIDGE: ${n.path}`;
          return n.path;
        })
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('forces');
    }

    function renderChurn() {
      currentView = 'churn';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const maxChurn = Math.max(1, ...graphData.nodes.map(n => n.churn || 0));

      const data = {
        nodes: graphData.nodes.map(n => {
          const score = (n.churn || 0) / maxChurn;
          return { ...n, color: nodeColor(n, healthColor(score)), size: nodeSize(n, 2 + (n.churn || 0) / maxChurn * 6) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: linkRgba(0.4),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} (${n.churn || 0} commits)`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('churn');
    }

    function renderCoverage() {
      currentView = 'coverage';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const tested = n.hasTests;
          const base = tested ? '#16a34a' : '#dc2626';
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: linkRgba(0.4),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} ${n.hasTests ? '(tested)' : '(untested)'}`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('coverage');
    }

    function applyForces() {
      if (!graph3d) return;
      const charge = graph3d.d3Force('charge');
      if (charge) charge.strength(cfg.charge);
      const link = graph3d.d3Force('link');
      if (link) link.distance(cfg.distance);
      graph3d.d3ReheatSimulation();
      // Attach module box updates to simulation ticks
      graph3d.onEngineTick(updateModuleBoxes);
    }

    function rerender() {
      clearModuleClouds();
      switch (currentView) {
        case 'galaxy': renderGalaxy(); break;
        case 'depflow': renderDepFlow(); break;
        case 'hotspot': renderHotspot(); break;
        case 'focus': renderFocus(focusNode || graphData.nodes[0]?.id); break;
        case 'module': renderModule(); break;
        case 'forces': renderForces(); break;
        case 'churn': renderChurn(); break;
        case 'coverage': renderCoverage(); break;
      }
    }

    function showDetail(node) {
      const panel = document.getElementById('detail');
      const content = document.getElementById('detail-content');
      content.innerHTML = '';

      const imports = graphData.edges.filter(e => e.source === node.id);
      const dependents = graphData.edges.filter(e => e.target === node.id);

      function metric(label, value) {
        return el('div', { className: 'metric' },
          el('span', { className: 'metric-label' }, label),
          el('span', { className: 'metric-value' }, String(value))
        );
      }

      function depItem(targetId, symbols, onClick) {
        const item = el('div', null, targetId + ' [' + symbols.join(', ') + ']');
        item.addEventListener('click', onClick);
        return item;
      }

      content.appendChild(el('h2', null, node.path));
      content.appendChild(metric('LOC', node.loc));
      content.appendChild(metric('Module', node.module));
      content.appendChild(metric('PageRank', (node.pageRank || 0).toFixed(4)));
      content.appendChild(metric('Betweenness', (node.betweenness || 0).toFixed(3)));
      content.appendChild(metric('Coupling', (node.coupling || 0).toFixed(2)));
      content.appendChild(metric('Fan In', node.fanIn || 0));
      content.appendChild(metric('Fan Out', node.fanOut || 0));
      content.appendChild(metric('Tension', (node.tension || 0).toFixed(2)));
      content.appendChild(metric('Bridge', node.isBridge ? 'Yes' : 'No'));
      content.appendChild(metric('Churn', (node.churn || 0) + ' commits'));
      const nodeCx = complexityLabel(node.cyclomaticComplexity || 1);
      const cxMetric = metric('Complexity', (node.cyclomaticComplexity || 1).toFixed(1) + ' — ' + nodeCx.text);
      cxMetric.querySelector('.metric-value').style.color = nodeCx.color;
      content.appendChild(cxMetric);
      content.appendChild(metric('Blast Radius', node.blastRadius || 0));
      content.appendChild(metric('Tests', node.hasTests ? (node.testFile || 'Yes') : 'None'));
      if (node.deadExports && node.deadExports.length > 0) {
        content.appendChild(el('div', { className: 'section-title' }, 'Dead Exports (' + node.deadExports.length + ')'));
        const deadList = el('div', { className: 'dep-list' });
        node.deadExports.forEach(name => deadList.appendChild(el('div', { style: { color: '#ef4444' } }, name)));
        content.appendChild(deadList);
      }

      if (node.functions && node.functions.length > 0) {
        content.appendChild(el('div', { className: 'section-title' }, 'Exports (' + node.functions.length + ')'));
        const exportList = el('div', { className: 'dep-list' });
        node.functions.forEach(f => exportList.appendChild(el('div', null, f.name + ' (' + f.loc + ' LOC)')));
        content.appendChild(exportList);
      }

      content.appendChild(el('div', { className: 'section-title' }, 'Dependencies (' + imports.length + ')'));
      const depsList = el('div', { className: 'dep-list' });
      if (imports.length === 0) {
        depsList.appendChild(el('div', null, 'None'));
      } else {
        imports.forEach(e => depsList.appendChild(depItem(e.target, e.symbols, () => navigateTo(e.target))));
      }
      content.appendChild(depsList);

      content.appendChild(el('div', { className: 'section-title' }, 'Dependents (' + dependents.length + ')'));
      const deptsList = el('div', { className: 'dep-list' });
      if (dependents.length === 0) {
        deptsList.appendChild(el('div', null, 'None'));
      } else {
        dependents.forEach(e => deptsList.appendChild(depItem(e.source, e.symbols, () => navigateTo(e.source))));
      }
      content.appendChild(deptsList);

      const focusBtn = el('button', {
        style: { marginTop: '12px', padding: '4px 10px', fontSize: '11px', background: '#2563eb', color: '#fff', border: 'none', borderRadius: '4px', cursor: 'pointer' }
      }, 'Focus View');
      focusBtn.addEventListener('click', () => renderFocus(node.id));
      content.appendChild(el('div', { style: { marginTop: '12px' } }, focusBtn));

      panel.classList.add('visible');
    }

    function navigateTo(nodeId) {
      const node = nodeById.get(nodeId);
      if (node) showDetail(node);
      if (currentView === 'focus') renderFocus(nodeId);
    }

    function closeDetail() {
      document.getElementById('detail').classList.remove('visible');
    }

    function updateLegend(view) {
      const legend = document.getElementById('legend');
      const legends = {
        galaxy: '<div class="item"><span>Node color = module | Node size = importance (PageRank)</span></div>',
        depflow: '<div class="item"><span>Top = entry points | Bottom = leaf deps | <span style="color:#dc2626">Red edges = circular deps</span></span></div>',
        hotspot: '<div class="item"><span style="color:#16a34a">Green = healthy</span> | <span style="color:#ea580c">Orange = moderate</span> | <span style="color:#dc2626">Red = high coupling</span> | Size = LOC</div>',
        focus: '<div class="item"><span style="color:#fbbf24">Yellow = selected</span> | Bright = neighbors | Faded = distant | Click to shift focus</div>',
        module: '<div class="item"><span>Color = module | <span style="color:#fbbf24">Yellow edges = cross-module deps</span></span></div>',
        forces: '<div class="item"><span style="color:#fbbf24">Yellow = tension</span> | <span style="color:#06b6d4">Cyan = bridge</span> | <span style="color:#ef4444">Red = junk drawer</span> | <span style="color:#22c55e">Green = extraction candidate</span></div>',
        churn: '<div class="item"><span style="color:#16a34a">Green = stable</span> | <span style="color:#ea580c">Orange = moderate churn</span> | <span style="color:#dc2626">Red = high churn</span> | Size = commit frequency</div>',
        coverage: '<div class="item"><span style="color:#16a34a">Green = has tests</span> | <span style="color:#dc2626">Red = untested</span> | Size = importance (PageRank)</div>',
      };
      legend.innerHTML = legends[view] || '';
    }

    function setupConfig() {
      let debounceTimer = null;
      function scheduleRerender() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(rerender, 150);
      }

      function liveUpdate(prop, val) {
        if (!graph3d) return;
        if (prop === 'nodeOpacity') graph3d.nodeOpacity(val);
        else if (prop === 'linkOpacity') graph3d.linkOpacity(val);
        else if (prop === 'charge') { applyForces(); return; }
        else if (prop === 'distance') { applyForces(); return; }
      }

      const sliders = [
        { id: 'cfg-nodeOpacity', key: 'nodeOpacity', valId: 'val-nodeOpacity', live: true, fmt: v => v.toFixed(2) },
        { id: 'cfg-nodeSize', key: 'nodeSize', valId: 'val-nodeSize', live: false, fmt: v => v.toFixed(1) },
        { id: 'cfg-isolatedDim', key: 'isolatedDim', valId: 'val-isolatedDim', live: false, fmt: v => v.toFixed(2) },
        { id: 'cfg-linkOpacity', key: 'linkOpacity', valId: 'val-linkOpacity', live: false, fmt: v => v.toFixed(2) },
        { id: 'cfg-linkWidth', key: 'linkWidth', valId: 'val-linkWidth', live: false, fmt: v => v.toFixed(1) },
        { id: 'cfg-charge', key: 'charge', valId: 'val-charge', live: true, fmt: v => String(Math.round(v)) },
        { id: 'cfg-distance', key: 'distance', valId: 'val-distance', live: true, fmt: v => String(Math.round(v)) },
      ];

      sliders.forEach(s => {
        const input = document.getElementById(s.id);
        const display = document.getElementById(s.valId);
        input.addEventListener('input', () => {
          const val = parseFloat(input.value);
          cfg[s.key] = val;
          display.textContent = s.fmt(val);
          if (s.live) liveUpdate(s.key, val);
          else scheduleRerender();
        });
      });

      document.getElementById('cfg-linkColor').addEventListener('input', (e) => {
        cfg.linkColor = e.target.value;
        scheduleRerender();
      });

      document.getElementById('cfg-moduleBoxes').addEventListener('change', (e) => {
        cfg.showModuleBoxes = e.target.checked;
        if (!cfg.showModuleBoxes) clearModuleClouds();
        else updateModuleBoxes();
      });

      const boxInput = document.getElementById('cfg-boxOpacity');
      const boxDisplay = document.getElementById('val-boxOpacity');
      boxInput.addEventListener('input', () => {
        cfg.boxOpacity = parseFloat(boxInput.value);
        boxDisplay.textContent = cfg.boxOpacity.toFixed(2);
        moduleClouds.forEach(obj => {
          obj.mesh.material.opacity = cfg.boxOpacity * 0.25;
        });
      });
    }

    function setupEvents() {
      // Close button
      document.getElementById('close-detail-btn').addEventListener('click', closeDetail);

      // View tabs
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const view = tab.dataset.view;
          switch (view) {
            case 'galaxy': renderGalaxy(); break;
            case 'depflow': renderDepFlow(); break;
            case 'hotspot': renderHotspot(); break;
            case 'focus': renderFocus(focusNode || graphData.nodes[0]?.id); break;
            case 'module': renderModule(); break;
            case 'forces': renderForces(); break;
            case 'churn': renderChurn(); break;
            case 'coverage': renderCoverage(); break;
          }
        });
      });

      // Search
      const searchInput = document.getElementById('search');
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        if (!query || !graph3d) return;
        const match = graphData.nodes.find(n => n.path.toLowerCase().includes(query) || n.label.toLowerCase().includes(query));
        if (match && graph3d.cameraPosition) {
          const node = graph3d.graphData().nodes.find(nd => nd.id === match.id);
          if (node) {
            graph3d.cameraPosition({ x: node.x + 100, y: node.y + 100, z: node.z + 100 }, node, 1000);
            showDetail(match);
          }
        }
      });
    }


    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // Auto-reload: detect server restart
    (function() {
      let wasDown = false;
      setInterval(async () => {
        try {
          const r = await fetch('/api/ping');
          if (wasDown && r.ok) location.reload();
          wasDown = false;
        } catch { wasDown = true; }
      }, 1000);
    })();
  </script>
</body>
</html>
