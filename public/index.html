<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Codebase Visualizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; color: #e0e0e0; font-family: 'Inter', -apple-system, sans-serif; overflow: hidden; }

    /* Header */
    #header {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; align-items: center; gap: 12px;
      padding: 8px 16px; background: rgba(10,10,15,0.9); border-bottom: 1px solid #222;
    }
    #header h1 { font-size: 14px; font-weight: 600; color: #fff; white-space: nowrap; }
    #stats { font-size: 12px; color: #888; }

    /* View selector */
    .view-tabs { display: flex; gap: 4px; margin-left: 16px; }
    .view-tab {
      padding: 4px 10px; font-size: 11px; border-radius: 4px;
      background: #1a1a24; color: #888; border: 1px solid #333;
      cursor: pointer; transition: all 0.2s;
    }
    .view-tab:hover { background: #252530; color: #ccc; }
    .view-tab.active { background: #2563eb; color: #fff; border-color: #2563eb; }

    /* Search */
    #search {
      margin-left: auto; padding: 4px 10px; font-size: 12px;
      background: #1a1a24; color: #e0e0e0; border: 1px solid #333;
      border-radius: 4px; outline: none; width: 200px;
    }
    #search:focus { border-color: #2563eb; }

    /* Graph container */
    #graph { width: 100vw; height: 100vh; }

    /* Detail panel */
    #detail {
      position: fixed; top: 48px; right: 0; width: 320px; max-height: calc(100vh - 48px);
      background: rgba(15,15,25,0.95); border-left: 1px solid #222;
      padding: 16px; overflow-y: auto; display: none; z-index: 50;
    }
    #detail.visible { display: block; }
    #detail h2 { font-size: 14px; color: #fff; margin-bottom: 8px; word-break: break-all; }
    #detail .metric { display: flex; justify-content: space-between; padding: 4px 0; font-size: 12px; border-bottom: 1px solid #1a1a24; }
    #detail .metric-label { color: #888; }
    #detail .metric-value { color: #e0e0e0; font-weight: 500; }
    #detail .section-title { font-size: 11px; color: #2563eb; text-transform: uppercase; margin-top: 12px; margin-bottom: 4px; }
    #detail .dep-list { font-size: 11px; color: #aaa; }
    #detail .dep-list div { padding: 2px 0; cursor: pointer; }
    #detail .dep-list div:hover { color: #2563eb; }
    #detail .close-btn {
      position: absolute; top: 8px; right: 8px; background: none; border: none;
      color: #666; cursor: pointer; font-size: 16px;
    }

    /* Legend */
    #legend {
      position: fixed; bottom: 16px; left: 16px; z-index: 50;
      background: rgba(15,15,25,0.9); border: 1px solid #222; border-radius: 6px;
      padding: 10px 14px; font-size: 11px;
    }
    #legend .item { display: flex; align-items: center; gap: 6px; padding: 2px 0; }
    #legend .dot { width: 8px; height: 8px; border-radius: 50%; }

    /* Force analysis legend */
    .force-legend { display: none; }
    .force-legend.visible { display: block; }

    /* Config panel */
    #config-toggle {
      position: fixed; bottom: 16px; right: 16px; z-index: 100;
      width: 36px; height: 36px; border-radius: 50%;
      background: #1a1a24; border: 1px solid #333; color: #888;
      font-size: 18px; cursor: pointer; transition: all 0.2s;
      display: flex; align-items: center; justify-content: center;
    }
    #config-toggle:hover { background: #252530; color: #fff; border-color: #2563eb; }
    #config-toggle.active { background: #2563eb; color: #fff; border-color: #2563eb; }

    #config-panel {
      position: fixed; bottom: 60px; right: 16px; z-index: 100;
      width: 240px; background: rgba(15,15,25,0.95);
      border: 1px solid #222; border-radius: 8px;
      padding: 16px; display: none; backdrop-filter: blur(10px);
    }
    #config-panel.visible { display: block; }

    .config-title {
      font-size: 12px; font-weight: 600; color: #fff;
      margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .config-section {
      font-size: 10px; color: #2563eb; text-transform: uppercase;
      margin: 12px 0 6px; letter-spacing: 0.5px;
    }
    .config-section:first-of-type { margin-top: 0; }
    .config-group { margin-bottom: 8px; }
    .config-group label {
      display: flex; justify-content: space-between;
      font-size: 11px; color: #888; margin-bottom: 3px;
    }
    .config-group label span { color: #e0e0e0; font-weight: 500; min-width: 32px; text-align: right; }
    .config-group input[type="range"] {
      width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
      background: #333; border-radius: 2px; outline: none;
    }
    .config-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px;
      border-radius: 50%; background: #2563eb; cursor: pointer;
    }
    .config-group input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border: none;
      border-radius: 50%; background: #2563eb; cursor: pointer;
    }
    .config-group input[type="color"] {
      width: 32px; height: 20px; border: 1px solid #333; border-radius: 3px;
      background: none; cursor: pointer; padding: 0;
    }
    .config-color-row {
      display: flex; align-items: center; justify-content: space-between;
      font-size: 11px; color: #888; margin-bottom: 8px;
    }
    .config-color-row span { color: #e0e0e0; }
  </style>
</head>
<body>
  <div id="header">
    <h1>Codebase Visualizer</h1>
    <span id="stats"></span>
    <div class="view-tabs">
      <div class="view-tab active" data-view="galaxy">Galaxy</div>
      <div class="view-tab" data-view="depflow">Dep Flow</div>
      <div class="view-tab" data-view="hotspot">Hotspot</div>
      <div class="view-tab" data-view="focus">Focus</div>
      <div class="view-tab" data-view="module">Module</div>
      <div class="view-tab" data-view="forces">Forces</div>
    </div>
    <input id="search" type="text" placeholder="Search files..." />
  </div>
  <div id="graph"></div>
  <div id="detail">
    <button class="close-btn" id="close-detail-btn">&times;</button>
    <div id="detail-content"></div>
  </div>
  <div id="legend"></div>

  <button id="config-toggle" title="Settings">&#9881;</button>
  <div id="config-panel">
    <div class="config-title">Settings</div>
    <div class="config-section">Nodes</div>
    <div class="config-group">
      <label>Opacity <span id="val-nodeOpacity">0.9</span></label>
      <input type="range" id="cfg-nodeOpacity" min="0.1" max="1" step="0.05" value="0.9">
    </div>
    <div class="config-group">
      <label>Size <span id="val-nodeSize">1.0</span></label>
      <input type="range" id="cfg-nodeSize" min="0.2" max="3" step="0.1" value="1">
    </div>
    <div class="config-group">
      <label>Dim Isolated <span id="val-isolatedDim">0.3</span></label>
      <input type="range" id="cfg-isolatedDim" min="0" max="1" step="0.05" value="0.3">
    </div>
    <div class="config-section">Links</div>
    <div class="config-color-row">
      <span>Color</span>
      <input type="color" id="cfg-linkColor" value="#969696">
    </div>
    <div class="config-group">
      <label>Opacity <span id="val-linkOpacity">0.8</span></label>
      <input type="range" id="cfg-linkOpacity" min="0.05" max="1" step="0.05" value="0.8">
    </div>
    <div class="config-group">
      <label>Width <span id="val-linkWidth">0.3</span></label>
      <input type="range" id="cfg-linkWidth" min="0.1" max="3" step="0.1" value="0.3">
    </div>
    <div class="config-section">Physics</div>
    <div class="config-group">
      <label>Repulsion <span id="val-charge">-30</span></label>
      <input type="range" id="cfg-charge" min="-200" max="-5" step="5" value="-30">
    </div>
    <div class="config-group">
      <label>Distance <span id="val-distance">120</span></label>
      <input type="range" id="cfg-distance" min="30" max="500" step="10" value="120">
    </div>
  </div>

  <script src="https://unpkg.com/3d-force-graph@1"></script>
  <script>
    let graphData = null;
    let forceData = null;
    let graph3d = null;
    let currentView = 'galaxy';
    let focusNode = null;
    let nodeById = new Map();

    // Safe DOM helpers â€” prevent XSS
    function el(tag, attrs, ...children) {
      const node = document.createElement(tag);
      if (attrs) {
        for (const [k, v] of Object.entries(attrs)) {
          if (k === 'style' && typeof v === 'object') {
            Object.assign(node.style, v);
          } else if (k.startsWith('on') && typeof v === 'function') {
            node.addEventListener(k.slice(2), v);
          } else if (k === 'className') {
            node.className = v;
          } else {
            node.setAttribute(k, v);
          }
        }
      }
      for (const child of children) {
        if (typeof child === 'string') node.appendChild(document.createTextNode(child));
        else if (child instanceof Node) node.appendChild(child);
      }
      return node;
    }

    function text(str) { return document.createTextNode(String(str)); }

    // Color palette for modules
    const MODULE_COLORS = [
      '#2563eb', '#dc2626', '#16a34a', '#9333ea', '#ea580c',
      '#0891b2', '#ca8a04', '#e11d48', '#4f46e5', '#059669'
    ];
    const moduleColorMap = new Map();
    let colorIdx = 0;

    function getModuleColor(mod) {
      if (!moduleColorMap.has(mod)) {
        moduleColorMap.set(mod, MODULE_COLORS[colorIdx % MODULE_COLORS.length]);
        colorIdx++;
      }
      return moduleColorMap.get(mod);
    }

    // Config state
    const cfg = {
      nodeOpacity: 0.9,
      nodeSize: 1.0,
      isolatedDim: 0.3,
      linkColor: '#969696',
      linkOpacity: 0.8,
      linkWidth: 0.3,
      charge: -30,
      distance: 120,
    };

    function linkRgba(alpha) {
      const h = cfg.linkColor;
      const r = parseInt(h.slice(1,3), 16);
      const g = parseInt(h.slice(3,5), 16);
      const b = parseInt(h.slice(5,7), 16);
      return `rgba(${r},${g},${b},${alpha ?? cfg.linkOpacity})`;
    }

    function isIsolated(n) { return n.fanIn === 0 && n.fanOut === 0; }

    function dimColor(hex, factor) {
      let r, g, b;
      if (hex.startsWith('#')) {
        r = parseInt(hex.slice(1,3), 16);
        g = parseInt(hex.slice(3,5), 16);
        b = parseInt(hex.slice(5,7), 16);
      } else if (hex.startsWith('rgb')) {
        const m = hex.match(/(\d+)/g);
        if (!m) return hex;
        r = +m[0]; g = +m[1]; b = +m[2];
      } else { return hex; }
      return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
    }

    function nodeColor(n, baseColor) {
      return isIsolated(n) ? dimColor(baseColor, cfg.isolatedDim) : baseColor;
    }

    function nodeSize(n, baseSize) {
      return (isIsolated(n) ? baseSize * cfg.isolatedDim : baseSize) * cfg.nodeSize;
    }

    // Health color: green -> orange -> red
    function healthColor(score) {
      const r = Math.min(255, Math.floor(score * 2 * 255));
      const g = Math.min(255, Math.floor((1 - score) * 2 * 255));
      return `rgb(${r},${g},60)`;
    }

    async function init() {
      try {
        const [graphRes, forcesRes] = await Promise.all([
          fetch('/api/graph'),
          fetch('/api/forces')
        ]);
        if (!graphRes.ok || !forcesRes.ok) throw new Error('Server returned error');
        graphData = await graphRes.json();
        forceData = await forcesRes.json();
      } catch (err) {
        document.getElementById('graph').innerHTML = '';
        document.getElementById('graph').appendChild(
          el('div', { style: { color: '#ef4444', padding: '40px', textAlign: 'center', fontSize: '16px' } },
            'Failed to load graph data: ' + (err instanceof Error ? err.message : String(err))
          )
        );
        return;
      }

      // Build O(1) lookup map
      nodeById = new Map(graphData.nodes.map(n => [n.id, n]));

      document.getElementById('stats').textContent =
        `${graphData.stats.totalFiles} files | ${graphData.stats.totalFunctions} functions | ${graphData.stats.totalDependencies} deps | ${graphData.stats.circularDeps.length} circular`;

      renderGalaxy();
      setupEvents();
      setupConfig();
    }

    function renderGalaxy() {
      currentView = 'galaxy';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: e.isTypeOnly ? linkRgba(0.4) : linkRgba(0.6),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} (${n.loc} LOC)`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .linkOpacity(cfg.linkOpacity)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('galaxy');
    }

    function renderDepFlow() {
      currentView = 'depflow';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const circularPairs = new Set();
      (graphData.stats.circularDeps || []).forEach(cycle => {
        for (let i = 0; i < cycle.length - 1; i++) {
          circularPairs.add(`${cycle[i]}->${cycle[i+1]}`);
        }
      });

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: circularPairs.has(`${e.source}->${e.target}`) || circularPairs.has(`${e.target}->${e.source}`)
            ? 'rgba(220,38,38,0.8)' : linkRgba(0.6),
          width: circularPairs.has(`${e.source}->${e.target}`) ? 2 : cfg.linkWidth,
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .dagMode('td')
        .dagLevelDistance(50)
        .nodeLabel(n => n.path)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('depflow');
    }

    function renderHotspot() {
      currentView = 'hotspot';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = healthColor(n.coupling);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 1 + n.loc / 20) };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: linkRgba(0.5),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.path} (coupling: ${n.coupling.toFixed(2)})`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('hotspot');
    }

    function renderFocus(targetId) {
      currentView = 'focus';
      focusNode = targetId;
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const neighbors = new Set();
      neighbors.add(targetId);
      graphData.edges.forEach(e => {
        if (e.source === targetId) { neighbors.add(e.target); }
        if (e.target === targetId) { neighbors.add(e.source); }
      });
      // 2-hop
      const hop2 = new Set(neighbors);
      graphData.edges.forEach(e => {
        if (neighbors.has(e.source)) hop2.add(e.target);
        if (neighbors.has(e.target)) hop2.add(e.source);
      });

      const data = {
        nodes: graphData.nodes.map(n => {
          const inFocus = hop2.has(n.id);
          return {
            ...n,
            color: n.id === targetId ? '#fbbf24'
              : neighbors.has(n.id) ? getModuleColor(n.module)
              : inFocus ? getModuleColor(n.module)
              : '#1a1a24',
            size: (n.id === targetId ? 8 : neighbors.has(n.id) ? 4 : inFocus ? 2 : 0.5) * cfg.nodeSize,
          };
        }),
        links: graphData.edges.map(e => ({
          source: e.source, target: e.target,
          color: (hop2.has(e.source) && hop2.has(e.target)) ? linkRgba(0.7) : linkRgba(0.1),
        }))
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => n.path)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(cfg.linkWidth)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => {
          if (n.id !== targetId) renderFocus(n.id);
          showDetail(n);
        });

      applyForces();
      updateLegend('focus');
    }

    function renderModule() {
      currentView = 'module';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const data = {
        nodes: graphData.nodes.map(n => {
          const base = getModuleColor(n.module);
          return { ...n, color: nodeColor(n, base), size: nodeSize(n, 2 + Math.sqrt(n.pageRank * 10000)) };
        }),
        links: graphData.edges.map(e => {
          const sn = nodeById.get(e.source);
          const tn = nodeById.get(e.target);
          const crossModule = sn && tn && sn.module !== tn.module;
          return {
            source: e.source, target: e.target,
            color: crossModule ? 'rgba(255,200,50,0.5)' : linkRgba(0.4),
            width: crossModule ? 1.5 : cfg.linkWidth,
          };
        })
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => `${n.module}${n.label}`)
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('module');
    }

    function renderForces() {
      currentView = 'forces';
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const tensionSet = new Set(forceData.tensionFiles.map(t => t.file));
      const bridgeSet = new Set(forceData.bridgeFiles.map(b => b.file));
      const junkModules = new Set(forceData.moduleCohesion.filter(m => m.verdict === 'JUNK_DRAWER').map(m => m.path));
      const extractModules = new Set(forceData.extractionCandidates.map(e => e.target));

      const data = {
        nodes: graphData.nodes.map(n => {
          let color = getModuleColor(n.module);
          let size = 2 + Math.sqrt(n.pageRank * 10000);

          if (tensionSet.has(n.id)) { color = '#fbbf24'; size *= 1.5; } // Yellow for tension
          else if (bridgeSet.has(n.id)) { color = '#06b6d4'; size *= 1.3; } // Cyan for bridges
          else if (junkModules.has(n.module)) { color = '#ef4444'; } // Red for junk drawer members
          else if (extractModules.has(n.module)) { color = '#22c55e'; } // Green for extraction candidates

          return { ...n, color: nodeColor(n, color), size: nodeSize(n, size) };
        }),
        links: graphData.edges.map(e => {
          const sn = nodeById.get(e.source);
          const tn = nodeById.get(e.target);
          const crossModule = sn && tn && sn.module !== tn.module;
          return {
            source: e.source, target: e.target,
            color: crossModule ? 'rgba(239,68,68,0.4)' : linkRgba(0.4),
            width: crossModule ? 1 : cfg.linkWidth,
          };
        })
      };

      graph3d = ForceGraph3D()(container)
        .graphData(data)
        .nodeLabel(n => {
          if (tensionSet.has(n.id)) return `TENSION: ${n.path}`;
          if (bridgeSet.has(n.id)) return `BRIDGE: ${n.path}`;
          return n.path;
        })
        .nodeColor(n => n.color)
        .nodeVal(n => n.size)
        .nodeOpacity(cfg.nodeOpacity)
        .linkColor(l => l.color)
        .linkWidth(l => l.width)
        .backgroundColor('#0a0a0f')
        .onNodeClick(n => showDetail(n));

      applyForces();
      updateLegend('forces');
    }

    function applyForces() {
      if (!graph3d) return;
      const charge = graph3d.d3Force('charge');
      if (charge) charge.strength(cfg.charge);
      const link = graph3d.d3Force('link');
      if (link) link.distance(cfg.distance);
      graph3d.d3ReheatSimulation();
    }

    function rerender() {
      switch (currentView) {
        case 'galaxy': renderGalaxy(); break;
        case 'depflow': renderDepFlow(); break;
        case 'hotspot': renderHotspot(); break;
        case 'focus': renderFocus(focusNode || graphData.nodes[0]?.id); break;
        case 'module': renderModule(); break;
        case 'forces': renderForces(); break;
      }
    }

    function showDetail(node) {
      const panel = document.getElementById('detail');
      const content = document.getElementById('detail-content');
      content.innerHTML = '';

      const imports = graphData.edges.filter(e => e.source === node.id);
      const dependents = graphData.edges.filter(e => e.target === node.id);

      function metric(label, value) {
        return el('div', { className: 'metric' },
          el('span', { className: 'metric-label' }, label),
          el('span', { className: 'metric-value' }, String(value))
        );
      }

      function depItem(targetId, symbols, onClick) {
        const item = el('div', null, targetId + ' [' + symbols.join(', ') + ']');
        item.addEventListener('click', onClick);
        return item;
      }

      content.appendChild(el('h2', null, node.path));
      content.appendChild(metric('LOC', node.loc));
      content.appendChild(metric('Module', node.module));
      content.appendChild(metric('PageRank', (node.pageRank || 0).toFixed(4)));
      content.appendChild(metric('Betweenness', (node.betweenness || 0).toFixed(3)));
      content.appendChild(metric('Coupling', (node.coupling || 0).toFixed(2)));
      content.appendChild(metric('Fan In', node.fanIn || 0));
      content.appendChild(metric('Fan Out', node.fanOut || 0));
      content.appendChild(metric('Tension', (node.tension || 0).toFixed(2)));
      content.appendChild(metric('Bridge', node.isBridge ? 'Yes' : 'No'));

      if (node.functions && node.functions.length > 0) {
        content.appendChild(el('div', { className: 'section-title' }, 'Exports (' + node.functions.length + ')'));
        const exportList = el('div', { className: 'dep-list' });
        node.functions.forEach(f => exportList.appendChild(el('div', null, f.name + ' (' + f.loc + ' LOC)')));
        content.appendChild(exportList);
      }

      content.appendChild(el('div', { className: 'section-title' }, 'Dependencies (' + imports.length + ')'));
      const depsList = el('div', { className: 'dep-list' });
      if (imports.length === 0) {
        depsList.appendChild(el('div', null, 'None'));
      } else {
        imports.forEach(e => depsList.appendChild(depItem(e.target, e.symbols, () => navigateTo(e.target))));
      }
      content.appendChild(depsList);

      content.appendChild(el('div', { className: 'section-title' }, 'Dependents (' + dependents.length + ')'));
      const deptsList = el('div', { className: 'dep-list' });
      if (dependents.length === 0) {
        deptsList.appendChild(el('div', null, 'None'));
      } else {
        dependents.forEach(e => deptsList.appendChild(depItem(e.source, e.symbols, () => navigateTo(e.source))));
      }
      content.appendChild(deptsList);

      const focusBtn = el('button', {
        style: { marginTop: '12px', padding: '4px 10px', fontSize: '11px', background: '#2563eb', color: '#fff', border: 'none', borderRadius: '4px', cursor: 'pointer' }
      }, 'Focus View');
      focusBtn.addEventListener('click', () => renderFocus(node.id));
      content.appendChild(el('div', { style: { marginTop: '12px' } }, focusBtn));

      panel.classList.add('visible');
    }

    function navigateTo(nodeId) {
      const node = nodeById.get(nodeId);
      if (node) showDetail(node);
      if (currentView === 'focus') renderFocus(nodeId);
    }

    function closeDetail() {
      document.getElementById('detail').classList.remove('visible');
    }

    function updateLegend(view) {
      const legend = document.getElementById('legend');
      const legends = {
        galaxy: '<div class="item"><span>Node color = module | Node size = importance (PageRank)</span></div>',
        depflow: '<div class="item"><span>Top = entry points | Bottom = leaf deps | <span style="color:#dc2626">Red edges = circular deps</span></span></div>',
        hotspot: '<div class="item"><span style="color:#16a34a">Green = healthy</span> | <span style="color:#ea580c">Orange = moderate</span> | <span style="color:#dc2626">Red = high coupling</span> | Size = LOC</div>',
        focus: '<div class="item"><span style="color:#fbbf24">Yellow = selected</span> | Bright = neighbors | Faded = distant | Click to shift focus</div>',
        module: '<div class="item"><span>Color = module | <span style="color:#fbbf24">Yellow edges = cross-module deps</span></span></div>',
        forces: '<div class="item"><span style="color:#fbbf24">Yellow = tension</span> | <span style="color:#06b6d4">Cyan = bridge</span> | <span style="color:#ef4444">Red = junk drawer</span> | <span style="color:#22c55e">Green = extraction candidate</span></div>',
      };
      legend.innerHTML = legends[view] || '';
    }

    function setupEvents() {
      // Close button
      document.getElementById('close-detail-btn').addEventListener('click', closeDetail);

      // View tabs
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const view = tab.dataset.view;
          switch (view) {
            case 'galaxy': renderGalaxy(); break;
            case 'depflow': renderDepFlow(); break;
            case 'hotspot': renderHotspot(); break;
            case 'focus': renderFocus(focusNode || graphData.nodes[0]?.id); break;
            case 'module': renderModule(); break;
            case 'forces': renderForces(); break;
          }
        });
      });

      // Search
      const searchInput = document.getElementById('search');
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        if (!query || !graph3d) return;
        const match = graphData.nodes.find(n => n.path.toLowerCase().includes(query) || n.label.toLowerCase().includes(query));
        if (match && graph3d.cameraPosition) {
          const node = graph3d.graphData().nodes.find(nd => nd.id === match.id);
          if (node) {
            graph3d.cameraPosition({ x: node.x + 100, y: node.y + 100, z: node.z + 100 }, node, 1000);
            showDetail(match);
          }
        }
      });
    }

    function setupConfig() {
      const toggle = document.getElementById('config-toggle');
      const panel = document.getElementById('config-panel');

      toggle.addEventListener('click', () => {
        panel.classList.toggle('visible');
        toggle.classList.toggle('active');
      });

      let debounceTimer = null;
      function scheduleRerender() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(rerender, 150);
      }

      function liveUpdate(prop, val) {
        if (!graph3d) return;
        if (prop === 'nodeOpacity') graph3d.nodeOpacity(val);
        else if (prop === 'linkOpacity') graph3d.linkOpacity(val);
        else if (prop === 'charge') { applyForces(); return; }
        else if (prop === 'distance') { applyForces(); return; }
      }

      const sliders = [
        { id: 'cfg-nodeOpacity', key: 'nodeOpacity', valId: 'val-nodeOpacity', live: true, fmt: v => v.toFixed(2) },
        { id: 'cfg-nodeSize', key: 'nodeSize', valId: 'val-nodeSize', live: false, fmt: v => v.toFixed(1) },
        { id: 'cfg-isolatedDim', key: 'isolatedDim', valId: 'val-isolatedDim', live: false, fmt: v => v.toFixed(2) },
        { id: 'cfg-linkOpacity', key: 'linkOpacity', valId: 'val-linkOpacity', live: false, fmt: v => v.toFixed(2) },
        { id: 'cfg-linkWidth', key: 'linkWidth', valId: 'val-linkWidth', live: false, fmt: v => v.toFixed(1) },
        { id: 'cfg-charge', key: 'charge', valId: 'val-charge', live: true, fmt: v => String(Math.round(v)) },
        { id: 'cfg-distance', key: 'distance', valId: 'val-distance', live: true, fmt: v => String(Math.round(v)) },
      ];

      sliders.forEach(s => {
        const input = document.getElementById(s.id);
        const display = document.getElementById(s.valId);

        input.addEventListener('input', () => {
          const val = parseFloat(input.value);
          cfg[s.key] = val;
          display.textContent = s.fmt(val);
          if (s.live) liveUpdate(s.key, val);
          else scheduleRerender();
        });
      });

      // Link color picker
      document.getElementById('cfg-linkColor').addEventListener('input', (e) => {
        cfg.linkColor = e.target.value;
        scheduleRerender();
      });
    }

    init();

    // Auto-reload: detect server restart
    (function() {
      let wasDown = false;
      setInterval(async () => {
        try {
          const r = await fetch('/api/ping');
          if (wasDown && r.ok) location.reload();
          wasDown = false;
        } catch { wasDown = true; }
      }, 1000);
    })();
  </script>
</body>
</html>
